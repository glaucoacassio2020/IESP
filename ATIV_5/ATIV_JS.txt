1)
a) Olá, Leandro! Você nasceu em 1980.
Porque a variável idade é uma string "45", mas quando faço idade - 0 vira 45. A variavel anoNascimento recebe o anoAtual - idadeNumero = 2025 – 45 = 1980.
Como 45 > 30, entra no IF e mostra a mensagem acima.

b) Sim. Nesta parte idade - 0, o JavaScript converte automaticamente a string "45" para número (inteiro).

c) c) Não. A variável idade já seria número então idadeNumero = 45 - 0 continua 45. Resultado final é o mesmo.

d) Sim, porque var tem escopo de função ou global, enquanto let tem escopo de bloco. Em códigos maiores isso pode causar variáveis sobrescrevendo outras sem querer, dificultando a manutenção e podendo gerar bugs.


2) a) 
Primeiro declarou as variáveis:
var x = "10";   // string
let y = 5;

Depois criou a variável resultado que recebe o valor retornado pela função calcular(a) entao é executada a função calcular(10):
var x = a + y;


a = 10

y = 5

a + y = 15 (numero)

Dentro da função essa variável x SOMBREIA a variavel x global.

if (x == "15")


x é 15 (number)

"15" é string

O operador == faz a conversão para número. Logo ela é verdadeira a condição.
x = x + 5;  // 15 + 5 = 20

A função retorna o valor 20 para resultado:
Tipo de 20 é "number"
Então cai no case:

resultado = resultado + "3";


number + string ocorre a concatenação
resultado = "203"


No código aqui:
for (let i = 0; i < 3; i++) {
  if (i == 1) {
    var x = x * 2;
  }
}


Quando i == 1:

Ele pega o x global que vale "10"

"10" * 2 faz a coerção automática e x vira 20.


SAÍDA FINAL
a) 203
   20


b) 
* Hoisting
var x global
var x dentro da função calcular
var x dentro do for


* Sombras acontece dentro de calcular existe var x que sombreia com x global.

* Conversões automáticas e coerção
if (x == "15")
== faz coerção e compara 15 (number) com "15" (string) convertida para número.

"10" * 2 no for

string é convertida para número.
resultado + "3"

número vira string com a concatenação então se torna "203".


c) Por que o switch cai no case "number"?

Porque resultado = 20 e typeof de 20 é "number".

Logo depois disso o código faz:
resultado = resultado + "3";

Transformando-o em string, mas isso ocorre dentro do próprio case.


d) Porque x foi declarado com var que tem escopo global então var x dentro do for é o mesmo x global.

Assim:

var x = x * 2;
modifica o x global.

Se fosse let x teria criado um novo x apenas dentro do bloco.

e) 
<script>
let x = 10;       // número real
const y = 5;

function calcular(a) {
  const valor = a + y;   // número garantido

  if (valor === 15) {
    return valor + 5;
  }

  return valor;
}

let resultado = calcular(10);

switch (typeof resultado) {
  case "string":
    resultado = Number(resultado) - 3;
    break;
  case "number":
    resultado = String(resultado) + "3";
    break;
  default:
    resultado = "erro";
}

for (let i = 0; i < 3; i++) {
  if (i === 1) {
    x = x * 2;  // agora x é let e não causa shadowing nem hoisting
  }
}

document.write(resultado + "<br>");
document.write(x);
</script>


